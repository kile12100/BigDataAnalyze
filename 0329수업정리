지난 수업에서는 우리가 빅데이터분석에 앞서서 데이터들을 좀 더 다루기 쉽게 하기위해서 선형변환과 기하,벡터를 선행했다.
이번 시간에서는 빅데이터분석을 위한 도구인 파이썬 문법에 대해서 간략하게 배웠다.
우선 우리가 어떤 자료들을 받았을 때, 이 자료들을 어떻게 정리할까?
일반 회사의 경우를 생각했을땐, 그 자료의 내용을 엑셀과 같은 프로그램에 수치값들을 정렬하여 하나의 리스트로 나열하여 만든다.
이처럼 파이썬에서도 여러 값들을 나열하여 리스트로 뽑을 수 있는데, 여러 형태의 집합표기방법들이 있고 다음과 같다.

list, tuple, set, dictionary

1. list
리스트는 말 그대로 일련의 값들을 나열하는 것을 뜻한다.
리스트에 들어갈 수 있는 데이터의 유형들은 정수, 문자열, True/False값 등이 있다.

ex) a = [1,2,3,'seungmin',True]

리스트를 선언할 때에는 위의 예시처럼 [](대괄호)를 사용한다.
그리고 인덱싱을 활용해서 특정 위치의 값을 변경이 가능하다.
ex) a[2] = 3 이라 지정하면 a의 값은 [1,3,3,'seungmin',True]이 된다
인덱싱은 바로 다음에서 다뤄보자.

1-1. 인덱싱과 슬라이싱, 스트라이드
우리가 집합을 통해 나열한 값들을 선언하고 저장하여 사용한다는 것은 알겠다.
그렇다면 만약에 그 집합에서 특정값들만 사용한다고하면 어떻게 해야할까?
이때 사용하는 개념이 인덱싱, 슬라이싱, 스트라이드이다.

i) 인덱싱
인덱싱은 집합에서 특정순서에 존재하는 값을 지정하는 개념으로 리스트 튜플 등에서 사용 가능하다.

ex) a = [1,2,3]    // 2를 찾고싶다면 두 번째에 위치하므로 a[1]라고 표기한다.
주의해야할 점은 집합에 속한 값들에게 순서를 지정해줄 때는 1부터 시작하는게 아닌 0부터 시작한다.
따라서 위의 예시와 값이 두 번째 값인 2를 찾으로면 집합에서는 1의 위치인 a[1]이 된다.

하지만, 만약의 데이터값이 a = [1,2,3,,,,,0]와 같이 굉장히 방대하게 있는데, 가장 마지막에 있는 값인 0를 지정하고자 한다면 어떻게 해야할까?
이럴 땐, -1를 사용한다면 뒤에서부터 지정하게 된다.
즉, 뒤에서 첫 번째 값이라면 a[-1], 뒤에서 두 번째 값은 a[-2]를 지정해주면 된다.

ii) 슬라이싱
인덱싱을 통해서 특정값을 지정할 수 있음을 알았지만, 우리는 궁금한 점이 또 생겼다.
바로 특정위치에 존재하는 여러 값들은 어떻게 지정하는가? 이다.
이 질문의 정답은 바로 슬라이싱에 있다.

ex) a = [1,2,3,4,5,6,7,8,9] // 두 번째값부터 다섯 번째 값을 지정할 때,  a[2:5]
위의 예시와 값이 시작할 값과 종료할 값 사이에 :(콜론)을 붙여주면 된다.
주의해야할 점은 종료할 값의 위치는 +1을 해줘야한다.
그렇기 때문에 위와 값이 5번째 값이라면 종료할 값은 4가 아닌 5가 되야 a[4]의 값까지 포함이 된다.

또한, 여기서 끝에서부터 특정값을 가져올 때, -부호를 사용한다고 했는데 여기서도 적용 가능하다.
ex) a[-3:-1]은 뒤에서 세 번째인 7부터 뒤에서 두번째인 8까지의 값들이 지정된다.

이 슬라이싱을 사용할 때, 만약 시작값이나 끝의 값까지 지정을 한다면 좀 더 편리하게 사용하기 위해 시작/종료값을 입력하지 않아도 된다.
ex) 처음부터 5번째까지의 값은 a[:5], 5번째부터 끝까지의 값은 a[5:], 만약의 전체값 지정의 경우 a[:]가 된다.

iii) 스트라이드
이제 인덱싱과 스트라이드를 통해 특정값들만 지정할 수 있게 되었다.
하지만, 특정값들을 만약에 반복적인 주기로 지정해야하는 경우는 어떻게 할까?
이럴 떄 사용하는 것이 스트라이드이다.
ex) a = [1,2,3,4,5,6,7,8,9] // 두 번째부터 일곱 번째 값까지 하나는 건너뛰고 값을 지정한다면? a[2:7:2]
위의 예시와 같이 시작값:종료값:주기로 표현이 가능하다.

2. tuple
튜플의 경우는 고정된 리스트라고 생각하면 편하겠다.
만약에 여러 명이서 어떤 자료들을 분석하는 프로젝트를 진행한다고 가정해보자.
여기서 분석하기 위해서 받은 자료의 정보들은 굳이 수정할 필요가 없기 때문에, 수정될 상황조차 만들지 않게 하게끔 튜플을 사용할 수 있다.
튜플 역시 리스트와 같이 정수,문자열,참/거짓값을 넣을 수 있다.

ex) a = (1,2,3,'sunny',True)

튜플을 선언할 때는 ()소괄호를 사용하여 선언한다.
그리고 앞서 말했듯이 고정된 리스트값이기 때문에 앞의 리스트와 다르게 튜플 속의 값을 변경할 수가 없다.
하지만 잘 구분해야하는 것이 재정의와 수정인다.
ex) a = (1,2,3) // a[1] = 3 (x) // a = (3,2,1) (o)
위의 예시처럼 만약 특정값의 수정은 고정된 리스트이므로 변경이 안되지만, a라고 선언한 튜플을 다시 정의한다면 그것은 수정이 아니기에
오류가 생기지 않는다.

2-1 append
리스트와 튜플의 차이를 알게 된 지금, 리스트는 단순히 수정만 할 수 있을까?
정답은 아니다라는 것이다. 값을 추가하거나 뺄 수있는데, 수업에서는 추가하는 것을 배웠으므로 그것만 다뤄보겠다.
append는 리스트에 값을 추가하는 기능으로 다음과 같이 사용할 수 있다.
ex) a = [1,2,3] // 4를 추가하고 싶다면, a.append(4)
위의 예시와 같이 사용하며 만약에 특정 위치에 값을 추가하고 싶다면 값의 위치도 괄호안에 같이 써주면 된다.
주의해야할 점은 추가할 위치를 지정해주지 않는다면 가장 끝에 값이 추가된다.

3. set
집합의 개념은 수업에서 다루지 않았지만 집합에 있어서는 같이 봐야하므로 다루겠다.
집합은 쉽게 말해서 값들의 모임이다.
우리가 수학시간에 배웠던 집합을 생각하면 되겠다.
그렇기 때문에 중복된 값들은 한번씩만 표기가 된다.
ex) a = [1,2,3,2,1]라는 리트스가 집합으로 변환된다면 {1,2,3}으로 표기된다.
또한, 앞의 예시처럼 집합은 {}중괄호를 사용한다.

4.dictionary
우리가 집에서 각종 양념장이나 소금,설탕들을 같은 디자인의 통에 담았을 때, 어떻게 구분할까?
대부분의 집에서는 각 통에 이름을 써놓거나 알아보기 쉬운 라벨들을 붙일 것이다.
데이터도 특정 데이터값들을 알아보기 위해서 이름표를 붙이면 어떨까?
그럴 때 딕션너리를 사용한다면 간편하게 이용할 있다.

ex) dicts = {'name':'seungmin','major':'IT경영'}  // IT경영의 값을 부르고 싶으면 dicts['major']

위의 예시처럼 앞에선 이름표인 key값, 그 값에 따라오는 데이터값은 value값이라고 부른다.
만약에 key값들만 보고싶다면 dicts.keys()를 사용하고 dicts.values()는 values값들만 볼 수 있다.

EX) 번외(len, 추가정의)
우리는 특정 리스트나 집합들에 대해서 배웠다.
그 특정 위치의 값들을 지정하는 방법이나 추가하는 법도 배웠다.
그렇다면 그 리스트의 크기를 확인하는 방법은 무엇이 있을까?

ex) a = [1,2,3]  // len(a) // 결과값: 3

위의 예시처럼 len를 사용하면 된다. len은 length의 줄임말로 쉽게 말해서 데이터의 길이를 나타내는 함수다.

딕셔너리에서는 리스트와 다르게 빈 값에서 추가로 값들을 할당하는 것이 가능하다.

ex) bag = dict() // bag[1] = 'apple' , bag[2] = 'pear' // 결과값: {1:'apple',2:'pear'}

위의 예시처럼 빈 딕셔너리인 bag을 만들고 거기에 채워넣을 수 있다는 특징이 있다.


이제 각 집합데이터들의 유형과 특징들을 배웠다.
이제 이 데이터들을 원할하게 사용하기 위해서 다른 기능들을 볼 차례인데,
특정 조건에 부합하는 데이터들을 사용할 때나, 반복적으로 데이터를 특정작업을 걸치는 등의 행위를 할 때는 다음과 같은 기능들을 사용한다.

for, while, if

1. if
if문은 특정 조건에 부합했을 때 작동이 이루어질 수 있게 하는 대표적인 구문이다.

ex) if True:
      print('참입니다.')

위의 예시처럼 if문이 참일 때는 if문에 포함된 구문들이 작동을 하는 원리에 있다.
만약 거짓이라면 구문이 작동하지 않게 된다.

주의 사항으로는 들여쓰기가 있다.
위의 예시처럼 들여쓰기를 하지 않는다면 if문에 포함된 구문으로 인식하지 않아서 참/거짓을 확인하는 것과 별개로 작동하게 된다.

1-1. 비교연산자
비교연산자는 말 그대로 값들을 비교하는 연산자들이다.
이러한 값들은 결과가 참/거짓으로 나타난다는 특징이 있고 다음과같다.

ex) a = 1, b = 2 // a > b , a < b, a >= b , a <= b, a == b, a != b 

위의 예시의 종류가 대표적인 비교연산자이며 특징으로는 값이 같은지 확인하려면 ==인 점과 같이 않다는 !=인 점이 있다.

1-2. else
만약에 if문에서 참이 아니라 거짓인 경우에도 다른 구문이 작동한다면 어떻게 해야할까?
그럴 때 else를 사용한다.

ex) if Flase:
      print('참입니다')
    else:
      print('거짓입니다.')

위의 예시와 같이 if문이 참이라면 참일 때 구문이 작동하지만 거짓이라면 else문의 구문이 작동하게 된다.

1-3. elif
if문도 알고 else를 알게 되었다.
하지만 조건을 여러 번 확인할 때, if문을 단순히 많이 사용하는 것만 정답일까?
이럴 때 elif문을 사용할 수 있다.

ex)  if False:
        print('참입니다.')
    elif False:
        print('거짓과 참입니다.')
    else:
        print('거짓과 거짓입니다.')

위 예시와 같이 첫 번쨰 조건이 거짓일 땐, 다음으로 넘어가고 elif문에서 조건문을 확인해서 참이면 elif구문을 실행
거짓이면 다음으로 넘어가게 된다.
else와 차이점은 else는 거짓일 경우 그대로 실행지만 elif문은 별도의 조건문이 존재해 해당 조건문을 확인해야한다는 점이다.

2. for
for문은 대표적인 반복문으로 특정구문을 지정한 횟수만큼이나 반복하는 구문이다.

ex) for i in [4,3,2,1]      결과값 4,3,2,1
      print(i)

  for i in range(0,10):    결과값 0,1,2,3,4,5,6,7,8,9
    print(i)

위의 예시처럼 구문이 형성되는데, 특징은 지정한 횟수만큼을 반복하기도 하지만, 리스트가 통째로 들어가서 리스트의 값을 받아올 수도 있다는 점이다.

3. while
for문이 지정한 횟수만큼 반복하는 것이라면 while문은 조건이 만족하는 한에서 계속 반복하는 반복문이다.

ex) while(i<10):
      print(i)
      i += 1

위의 예시처럼 조건문이 참이면 반복하게 된다. 주의사항으로는 예시처럼 i += 1를 넣지않아서 계속해서 조건이 참이된다면
실행이 무한히 되어 중간에 강제로 중지시켜야하는데 이를 무한루프오류라고도 부르며 무한루프에 빠지지 않게 주의해야한다.

EX-1) break, continue
앞에서 반복문을 배웠는데, 이 중에서 주의할 사항으로 무한루프에 빠지지 않아야하는 경우를 얘기했다.
하지만, 반복을 무한하게 하면서 특정상황이 되는 경우에 반복문에서 빠지거나 특정 경우에만 구문을 건너뛰는 경우가 있는데
그럴 때 사용하는 것이 break, continue 구문이다.

ex) i = 0         결과값: 1,2,3 '3입니다.'
while True:
  print(i)
  i += 1
  if i == 3:
  print('3입니다.')
  break

위의 예시대로라면 항상 참이므로 무한히 반복하게 되지만 if문에서 i가 3일때 break를 걸었으므로 i가 3일 때 반복문을 빠져나오게 된다.
만약에 break에서 continue를 쓰게 된다면 3일때 숫자 3은 출력되지 않으면서 if문의 '3입니다'가 출력되고 뒤로 계속 i값이 출력된다.

EX-2) 구문의 중첩
여기까지 반복문과 조건문을 배웠다.
이 두 종류의 구문은 서로 중첩해서 쓰거나 섞어서 쓸수 있다는 점이 있는데, 다음 예시는 수업시간에서 활용한 문제들이다.

ex)  for i in range(1,10):                결과값: 구구단
      for j in range(1,10):
        print('%d * %d = %d %(i,j,i*j))

위의 예시처럼 for문을 여러번 중첩해서 사용가능하며 EX-1의 예시처럼 while문과 if문을 섞어서 사용할 수 있다.


이제 마지막 내용이다.
우리가 이렇게 여러 구문과 데이터형태들을 배웠는데, 만약에 우리가 특정 기능을 하는 구문을 만들고 
그 구문을 반복적으로 사용하고싶을 때 효율적으로 사용하는 방법이 있을까?
그럴 때, 함수를 사용한다면 문제가 해결된다.

1. def
def는 함수로 우리가 구문을 넣어둔다면 나중에 함수를 사용함으로써 반복적으로 해당구문을 재작성하지 않고 사용할 수 있다.

ex) def add(a,b):          결과값: 8
      return a + b  
    add(3,5)

위의 예시처럼 def를 통해 함수를 선언하고 함수명과 들여오는 파라미터를 지정해주고 마지막에는 리턴값을 지정해주면 된다.
특징으로는 여러 가지가 있는데 다음과 같다.
1. 파라미터는 받지 않을 수 있지만, 여러 개를 받을 수도 있다.
2. 리턴값도 존재할 수 있지만 존재하지 않아도 된다.
3. 함수를 선언할 때 사용하는 변수명은 함수 내에서만 사용한다.

1번의 경우는 함수를 선언할 떄, 파라미터값을 받음으로써 함수를 작동하는데 파라미터를 사용하는 경우도 있지만 그렇지 않는 경우도 있기에
발생하는 경우다.

ex) def print_p():
      print('p')

위의 예시는 1번과 2번을 둘 다 설명하는데, 만약  print_p()를 작동할 때는 특정 파라미터를 받지 않아도 구문을 진행하는데 지장이 없으므로
아예 파라미터를 받지 않게 했으며, 리턴값이 없어도 정상적으로 p를 출력하고 함수의 작동이 끝나는 것을 알 수 있다.
3번은 지역변수과 전역변수의 설명으로 앞의 예신에서 add함수를 보면 된다.
앞의 add예시에서 함수를 선언하기 전에 a,b의 값을 미리 선언하고 함수를 선언해도 함수의 파라미터인 a,b에 해당 값이 들어가지 않는다는 소리다.

EX) input
우리가 만약에 값을 받아온다고 할 때, 단순히 값을 선언하는 방법만 있을까?
사실 우리가 컴퓨터나 스마트폰을 사용할 때 우리가 입력을 하지 개발자들이 우리가 입력하고싶은 것들을 대신 입력해주는 것이 아니다.
당연하겠지만 코딩에서도 이처럼 처음에 선언해주는 방법 외에도 실행 시에 입력을 받을 수 있는데 바로 input이다.
input의 사용은 간단하게 input()이다.
우리가 자주 사용하는 print()의 반대라고 생각하면 쉽다.
값을 입력받아서 저장하려면 변수를 선언시 input을 사용하면 된다.
ex) a = input()

def nice_one():
  a = input()
  print(a,'nice one sonny')

nice_one()

위의 예시처럼 만약에 함수를 작동하면 a값에 입력값을 저장하고 출력하는 방식이 되겠다.


마지막으로 수업시간에 풀던 퀴즈를 설명으로 끝내겠다.

3개의 값을 받았을 때, 가장 큰 수를 반환받는 함수를 만들어라.

def max_find(a,b,c):
      max = 0
      if a > b:
            max = a
      else:
            max = b
      if max < c:
            max = c
      return max
